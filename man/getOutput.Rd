\name{getOutput}
\alias{getOutput}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{
Read Deep Process Convolution Results from File
}
\description{
Read output from the \code{\link{dpc}} function from a specified directory.
}
\usage{
getOutput(path = "./", draw_u = FALSE,
          Y = NULL, vars = NULL, seed = NULL,
          print_warn = TRUE, lite = FALSE)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{path}{A string with the path to the directory where the results from \code{\link{dpc}} are stored.}
  \item{draw_u}{Logical.  If \code{TRUE}, values of the latent variable u will be drawn and placed in a new directory in \code{path}.  Note, this will overwrite any values of u previously drawn.}
  \item{Y}{If \code{draw_u=TRUE}, \code{Y} is the same data used by \code{dpc} to create the files in \code{path}.}
  \item{vars}{If \code{draw_u=TRUE}, \code{vars} consists of the same variances used by \code{dpc} to create the files in \code{path}.}
  \item{seed}{An integer specifying a seed for use in drawing values of u, i.e., when \code{draw_u=TRUE}.  If \code{NULL} a random seed is used.}
  \item{print_warn}{Logical.  If \code{TRUE}, warnings generated by the C code when drawing u are displayed.}
  \item{lite}{Logical. When \code{lite=TRUE}, the values of u not read into the returned object.  This is intended to save memory and increase speed for large datasets and/or long MCMC runs.}
}

\value{
An object of class dpc.  The object is a list containing the following:

\item{hyperparms}{A dataframe with the initial hyperparmeters and number of smooth functions which were estimated.}

\item{k_u}{The grid locations of the latent vector u.}

\item{k_v}{The grid locations of the latent vector v.}

\item{lite}{A flag (logical) indicating if the draws of the latent variable u are included in the object.}

\item{locs}{A numeric vector of all of the unique locations of the data.}

\item{lpost}{A numeric vector with the value of the log of the function proportional to the posterior at each iteration of the MCMC.}

\item{postdraws}{A dataframe with the posterior draws of tau^2_u, tau^2_v, and delta.}

\item{us}{If \code{lite=FALSE}, a list of draws of the latent variable u for each of the smooth functions labeled uXXXX.  If \code{lite=TRUE}, a string with the local path to the directory where the draws of u are stored.}

\item{vs}{A matrix containing the posterior draws of the latent vector v.}
}
\references{
Lawrence, Earl, et al. The coyote universe. III. simulation suite and precision emulator for the nonlinear matter power spectrum. The Astrophysical Journal 713.2 (2010): 1322.
}
\author{
Richard D. Payne
}
\seealso{
\code{\link{plot.dpc}}, \code{\link{dpc}}
}
\examples{
\dontrun{
library(dpc)
set.seed(424)

# Create data from 3 smooth functions, 5 realizations each
vars <- Y <- list()
n <- 75 # number of observations per realization
f1 <- function(x) sin(x)
f2 <- function(x) cos(x)
f3 <- function(x) 1 + sin(x)
sds <- c(.5,1,1.5)
for(i in 1:3){
  varstmp <- Ytmp <- list()
  for(j in 1:5){
    # Random locations
    x <- sort(runif(n,0,2*pi))
    m <- do.call(paste0("f",i),alist(x=x))
    y <- m + rnorm(n,0,sds[i])
    Ytmp[[j]] <- cbind(x,y)
    varstmp[[j]] <- rep(sds[i]^2,n)
  }
  Y[[i]] <- Ytmp
  vars[[i]] <- varstmp
}

# Plot the realized data
par(mfrow=c(3,1))
for(i in 1:3){
  plot(Y[[i]][[1]],type='l')
  for(j in 2:5){
    lines(Y[[i]][[j]])
  }
}

# Run MCMC
out <- dpc(Y,vars,nmcmc=10^3,burn=10^3,n_u=15,n_v=5,
           seed=1,num_threads=1,draw_u = TRUE,
           out_dir="./output")
out2 <- getOutput("./output")
}
}
